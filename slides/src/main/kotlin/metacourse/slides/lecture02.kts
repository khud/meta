import io.kotex.beamer.column
import io.kotex.beamer.columns
import io.kotex.beamer.frame
import io.kotex.bibtex.cite
import io.kotex.core.*
import metacourse.slides.Bib
import metacourse.slides.createPreamble
import metacourse.slides.withImage

val doc = document(createPreamble("Языки программирования")) {
    makeTitle()

    section("Языки типа Lisp") {
        frame("Джон Маккарти") {
            withImage("../assets/mccarthy.png") {
                +"""${"Джон Маккарти".bold()} (англ. John McCarthy; 4 сентября 1927, Бостон — 24 октября 2011, Стэнфорд)
                — американский информатик, автор термина «искусственный интеллект» (1956), 
                изобретатель языка Лисп (1958)${footnote("History of Lisp:" + url("http://jmc.stanford.edu/articles/lisp/lisp.pdf"))}${cite(Bib.mcCarty60)}, 
                основоположник функционального программирования, 
                лауреат премии Тьюринга (1971) за огромный вклад в область исследований искусственного 
                интеллекта.""".footnote(url("https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)"))
            }
        }

        frame("Структура и интерпретация компьютерных программ") {
            withImage("../assets/sicp.png", ratio = 0.7) {
                +"""Компилятор любого функционального языка должен останавливать каждого,
                кто не читал эту книгу."""
            }
        }

        frame("Деревья абстрактного синтаксиса") {
            +"""
            Старайтесь избегать плохого перевода с английского термина ${"abstract syntax tree".textbf()}
            как абстрактное синтаксическое дерево. Дело в том что дерево на самом деле очень конкретное, а
            синтаксис абстрактный.
            """
        }

        frame("Атомы и S-выражения") {
            +"""S-выражения это выражения, состоящие из символов, от англ. ${"symbolic expressions".bold()},
            представляют собой (вложенные) списки. Например:"""

            verbatim("'((this is (a nested)) list (that (represents a) tree))")

            +"""Здесь ${verb("'this")} - это сокращенная форма для ${verb("(quote this)")}."""

            +"\n\n"

            +"Атомы - это листья S-выражений, как строки, только для них нельзя разложить посимвольно, т.е. они атомарны."
        }

        frame("S-выражения как деревья абстрактного синтаксиса") {
            +"""Lisp - это уникальный язык, в котором деревья абстрактного синтаксиса являются
            неотъемлемой частью языка.    
            """
        }

    }

    section("Введение в РЕФАЛ") {
        frame("Язык РЕФАЛ") {
            +"""РЕФАЛ (${"РЕ".bold()}курсивных ${"Ф".bold()}ункций ${"АЛ".bold()}горитмический) — один из старейших функциональных языков программирования, 
            ориентированный на символьные вычисления: обработку символьных строк. Созданный
            В. Турчиным в 1966 г. (первая реализация появилась в 1968 г).""".footnote(url("https://en.wikipedia.org/wiki/Refal"))
           
            +"Это один из первых языков, где было реализовано сопоставление с образцом."
        }

        frame("Зачем изучать РЕФАЛ?") {
            itemize {
                -"""Это очень полезно для понимания многих неочевидных концепций, которые будут использованы для 
                    нашего <<игрушечного>> языка TSG, для которого будут многие алгоритмы в этом курсе;"""
                -"""Для общего развития."""
            }
        }

        frame("Hello world") {
            verbatim("""
            ${"$"}ENTRY Go { = <Hello>;}
            Hello {
               = <Prout 'Hello world'>;
            }
            """)
        }

        frame("Сопоставление с образцом в РЕФАЛе") {
            columns {
                column(0.5 * textWidth()) {
                    verbatim("""
                    BinAdd {
                      '0' '0' = '0';
                      '0' '1' = '1';
                      '1' '0' = <BinAdd '0' '1'>;
                      '1' '1' = '10';
                    }""")
                }
                column(0.5 * textWidth()) {
                    verbatim("""
                    BinSub {
                      '0' '0' = '0';
                      '1' '1' = '0';
                      '1' '0' = '1';
                      '0' '1' = '-' <BinSub '1' '0'>;
                    }""")
                }
            }

            +"""${"Важное замечание".bold()}: каждый из знаков внутри одинарных кавычек является самостоятельным, 
            следующие записи эквивалентны: ${verb("'Hello'")}, ${verb("'Hel' 'lo'")}, 
            ${verb("'H' 'e' 'l' 'l' 'o'")}.""".footnote(url("https://bmstu-iu9.github.io/refal-5-lambda/3-basics.html"))
        }

        frame("Скучный пример") {
            verbatim("""
            IsEqual {
              '-1=-1' = 'True'; '-1=0' = 'False'; '-1=1' = 'False'; '-1=10' = 'False';
              '0=-1' = 'False'; '0=0' = 'True'; '0=1' = 'False'; '0=10' = 'True';
              '1=-1' = 'False'; '1=0' = 'False'; '1=1' = 'True'; '1=10' = 'False';
              '10=-1' = 'False'; '10=0' = 'False'; '10=1' = 'True'; '10=10' = 'True';
            }    
            """)

            verbatim("""
            ${'$'}ENTRY Go {
              = <Prout '1+0=0+1? ' <IsEqual <BinAdd '1' '0'> '=' <BinAdd '0' '1'>>>
                <Prout '1-0=0-1? ' <IsEqual <BinSub '1' '0'> '=' <BinSub '0' '1'>>>;
            }    
            """)
        }

        frame("Переменные") {
            +"""Множества значений, которые могут принимать переменные, определяются типом
            переменной. В Рефале есть три типа переменных: s-, t- и e-переменные.

            Значением s-переменной или переменной символа может быть любой одиночный символ
            (symbol). Значением e-переменной или переменной выражения может быть любой фрагмент
            аргумента функции, в том числе пустой.""".footnote("не совсем любой, на самом деле, но об этом позже")
        }

        frame("Примеры s- и e-выражений") {
            fun example(code: String, desc: String, examples: List<String>): String {
                return verb(code) + "-" + desc + examples.joinToString(separator = ",", transform = ::verb) + "."
            }
            itemize {
                -example("s.1 s.2 s.3", "три любых символа, например", listOf("'ABC'", "'999'", "'@#$'"))
                -example("s.A s.A s.A", "три любых одинаковых, символа, например", listOf("'666'", "'www'"))
                -example("s.Edge s.Middle s.Edge", "три любых символа, причём первый и последний должны совпадать. Например:", listOf("'@$@'", "'kek'", "'^_^'"))
                -example("s.first e.middle s.last", "любое выражение, содержащее как минимум два символа. Например:", listOf("'Hello'", "'10'","'0_o'"))
                -example("s.EDGE e.CENTER s.EDGE", "любое выражение как минимум из двух символов, начинающееся и заканчивающееся на одинаковый символ. Например:", listOf("'++'", "'LOOOL'", "'revolver'"))
                -example("'(' e.Inner ')'", "выражение, начинающееся и заканчивающееся на скобку. Примеры:", listOf("'()'", "'()()'", "'(ok)'"))
                -example("e.Key '=' e.Value", "выражение, содержащее хотя бы один знак равенства. Например:", listOf("'='", "'x=1'", "'-1=10'", "'A=B==C=D'"))
                -example("e.Eq e.Eq", "выражение чётной длины, которое можно разбить на две одинаковые половинки:", listOf("'ABCABC'", "'8888'", "''"))
            }
        }

    }

}

doc.write("../../../../../tex/lecture02.tex")