import io.kotex.beamer.column
import io.kotex.beamer.columns
import io.kotex.beamer.frame
import io.kotex.bibtex.cite
import io.kotex.core.*
import metacourse.slides.Bib
import metacourse.slides.createPreamble
import metacourse.slides.withImage

val doc = document(createPreamble("Языки программирования")) {
    makeTitle()

    section("Языки типа Lisp") {
        frame("Джон Маккарти") {
            withImage("../assets/mccarthy.png") {
                +"""${"Джон Маккарти".bold()} (англ. John McCarthy; 4 сентября 1927, Бостон — 24 октября 2011, Стэнфорд)
                — американский информатик, автор термина «искусственный интеллект» (1956), 
                изобретатель языка Лисп (1958)${footnote("History of Lisp:" + url("http://jmc.stanford.edu/articles/lisp/lisp.pdf"))}, 
                основоположник функционального программирования, 
                лауреат премии Тьюринга (1971) за огромный вклад в область исследований искусственного 
                интеллекта.""".footnote(url("https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)"))
            }
        }

        frame("Структура и интерпретация компьютерных программ") {
            withImage("../assets/sicp.png", ratio = 0.7) {
                +"""Компилятор любого функционального языка должен останавливать каждого,
                кто не читал эту книгу."""
            }
        }

        frame("Деревья абстрактного синтаксиса") {
            +"""
            Старайтесь избегать плохого перевода с английского термина ${"abstract syntax tree".textbf()}
            как абстрактное синтаксическое дерево. Дело в том что дерево на самом деле очень конкретное, а
            синтаксис абстрактный.
            """
        }

        frame("Атомы и S-выражения") {
            +"""S-выражения это выражения, состоящие из символов, от англ. ${"symbolic expressions".bold()},
            представляют собой (вложенные) списки. Например:"""

            verbatim("'((this is (a nested)) list (that (represents a) tree))")

            +"""Здесь ${verb("'this")} - это сокращенная форма для ${verb("(quote this)")}."""

            +"\n\n"

            +"Атомы - это листья S-выражений, как строки, только для них нельзя разложить посимвольно, т.е. они атомарны."
        }

        frame("S-выражения как деревья абстрактного синтаксиса") {
            +"""Lisp - это уникальный язык, в котором деревья абстрактного синтаксиса являются
            неотъемлемой частью языка.""".footnote("Здесь мы будем использовать диалект, который называется Scheme")
            verbatim("""
            (+ (* 3
                  (+ (* 2 4)
                     (+ 3 5)))
               (+ (- 10 7)
                  6))    
            """)
            verbatim("""
            (define (square x) (* x x))    
            """)
        }

        frame("Списки в языке Lisp") {
            verbatim("""
            (cons 1
                  (cons 2
                        (cons 3
                              (cons 4 nil))))    
            """)
            +"Или, если коротко, то:"
            verbatim("(list 1 2 3 4)")
            +"Функции ${verb("car")} и ${verb("cdr")} - это аналоги"
            +"${verb("head")} и ${verb("tail")}:"
            verbatim("""
            (car (list 1 2 3 4)) -> 1
            (cdr (list 1 2 3 4)) -> (2 3 4)   
            """)
        }

        frame("Реализация cons, car и cdr") {
            verbatim("""
            (define (cons x y)
                (define (dispatch m)
                    (cond ((= m 0) x)
                          ((= m 1) y)
                          (else (error "Аргумент не 0 или 1 -- CONS" m))))
            dispatch)
            
            (define (car z) (z 0))
            (define (cdr z) (z 1))    
            """)
        }

    }

    section("Введение в РЕФАЛ") {
        frame("Язык РЕФАЛ") {
            +"""РЕФАЛ (${"РЕ".bold()}курсивных ${"Ф".bold()}ункций ${"АЛ".bold()}горитмический) — один из старейших функциональных языков программирования, 
            ориентированный на символьные вычисления: обработку символьных строк. Созданный
            В. Турчиным в 1966 г. (первая реализация появилась в 1968 г).""".footnote(url("https://en.wikipedia.org/wiki/Refal"))

            +"Это один из первых языков, где было реализовано сопоставление с образцом."
        }

        frame("Зачем изучать РЕФАЛ?") {
            itemize {
                -"""Это очень полезно для понимания многих неочевидных концепций, которые будут использованы для 
                    нашего <<игрушечного>> языка TSG, для которого будут многие алгоритмы в этом курсе;"""
                -"""Для общего развития."""
            }
        }

        frame("Версии РЕФАЛа") {
            +"В настоящее время можно говорить о следующих версиях языка программирования РЕФАЛ:"
            itemize {
                -"РЕФАЛ-5".footnote(url("http://refal.ru/rf5_frm.htm"))
                -"РЕФАЛ-5$ \\lambda $".footnote(url("https://github.com/bmstu-iu9/refal-5-lambda"))
                -"РЕФАЛ-6".footnote(url("http://www.refal.net/~arklimov/refal6/"))
                -"РЕФАЛ+".footnote(url("http://www.refal.net/rfp_frm.html"))
            }
        }

        frame("Особенности") {
            itemize {
                -"Функции на РЕФАЛе принимают один аргумент".footnote("Кроме версии РЕФАЛ+")
                -"Нет вещественных чисел"
            }
        }

        frame("Hello world") {
            verbatim("""
            ${"$"}ENTRY Go { = <Hello>;}
            Hello {
               = <Prout 'Hello world'>;
            }
            """)
        }

        frame("Сопоставление с образцом в РЕФАЛе") {
            columns {
                column(0.5 * textWidth()) {
                    verbatim("""
                    BinAdd {
                      '0' '0' = '0';
                      '0' '1' = '1';
                      '1' '0' = <BinAdd '0' '1'>;
                      '1' '1' = '10';
                    }""")
                }
                column(0.5 * textWidth()) {
                    verbatim("""
                    BinSub {
                      '0' '0' = '0';
                      '1' '1' = '0';
                      '1' '0' = '1';
                      '0' '1' = '-' <BinSub '1' '0'>;
                    }""")
                }
            }

            +"""${"Важное замечание".bold()}: каждый из знаков внутри одинарных кавычек является самостоятельным, 
            следующие записи эквивалентны: ${verb("'Hello'")}, ${verb("'Hel' 'lo'")}, 
            ${verb("'H' 'e' 'l' 'l' 'o'")}.""".footnote(url("https://bmstu-iu9.github.io/refal-5-lambda/3-basics.html"))
        }

        frame("Скучный пример") {
            verbatim("""
            IsEqual {
              '-1=-1' = 'True'; '-1=0' = 'False'; '-1=1' = 'False'; '-1=10' = 'False';
              '0=-1' = 'False'; '0=0' = 'True'; '0=1' = 'False'; '0=10' = 'True';
              '1=-1' = 'False'; '1=0' = 'False'; '1=1' = 'True'; '1=10' = 'False';
              '10=-1' = 'False'; '10=0' = 'False'; '10=1' = 'True'; '10=10' = 'True';
            }    
            """)

            verbatim("""
            ${'$'}ENTRY Go {
              = <Prout '1+0=0+1? ' <IsEqual <BinAdd '1' '0'> '=' <BinAdd '0' '1'>>>
                <Prout '1-0=0-1? ' <IsEqual <BinSub '1' '0'> '=' <BinSub '0' '1'>>>;
            }    
            """)
        }

        frame("Переменные") {
            +"""Множества значений, которые могут принимать переменные, определяются типом
            переменной. В Рефале есть три типа переменных: s-, t- и e-переменные.

            Значением s-переменной или переменной символа может быть любой одиночный символ
            (symbol). Значением e-переменной или переменной выражения может быть любой фрагмент
            аргумента функции, в том числе пустой.""".footnote("не совсем любой, на самом деле, но об этом позже")
        }

        frame("Примеры s- и e-выражений") {
            fun example(code: String, desc: String, examples: List<String>): String {
                return verb(code) + "-" + desc + examples.joinToString(separator = ",", transform = ::verb) + "."
            }
            itemize {
                -example("s.1 s.2 s.3", "три любых символа, например", listOf("'ABC'", "'999'", "'@#$'"))
                -example("s.A s.A s.A", "три любых одинаковых, символа, например", listOf("'666'", "'www'"))
                -example("s.Edge s.Middle s.Edge", "три любых символа, причём первый и последний должны совпадать. Например:", listOf("'@$@'", "'kek'", "'^_^'"))
                -example("s.first e.middle s.last", "любое выражение, содержащее как минимум два символа. Например:", listOf("'Hello'", "'10'","'0_o'"))
                -example("s.EDGE e.CENTER s.EDGE", "любое выражение как минимум из двух символов, начинающееся и заканчивающееся на одинаковый символ. Например:", listOf("'++'", "'LOOOL'", "'revolver'"))
                -example("'(' e.Inner ')'", "выражение, начинающееся и заканчивающееся на скобку. Примеры:", listOf("'()'", "'()()'", "'(ok)'"))
                -example("e.Key '=' e.Value", "выражение, содержащее хотя бы один знак равенства. Например:", listOf("'='", "'x=1'", "'-1=10'", "'A=B==C=D'"))
                -example("e.Eq e.Eq", "выражение чётной длины, которое можно разбить на две одинаковые половинки:", listOf("'ABCABC'", "'8888'", "''"))
            }
        }

        frame("Процесс выполнения функции на РЕФАЛе") {
            itemize {
                -"""Выбирается предложение, из левой части которого можно получить аргумент 
                 функции путём замены переменных в ней на некоторые значения. Если таких 
                 предложений несколько, выбирается с наименьшим номером. Если такого 
                 предложения не нашлось, то программа завершается с ошибкой отождествления
                 (recognition impossible)."""
                -"""Фиксируются значения переменных, при подстановке которых в левую часть
                 выбранного предложения, та обращается в аргумент функции. Если таких наборов
                 значений переменных (подстановок) несколько, то фиксируется та из них, при
                 которой самая левая e-переменная принимает кратчайшее значение, если это не
                 разрешает неоднозначности, то рассматривается следующая e-переменная и т.д.
                 (в следующем разделе мы рассмотрим этот процесс подробнее)."""
                -"""В правой части выбранного предложения заменяются переменные на их значения.
                 После чего вычисляются функции в правой части."""
            }
        }

        frame("Примеры использования сопоставления с образцом") {
            verbatim("""
            IsEqual {
              e.Equal '=' e.Equal = 'True';
              e.Left '=' e.Right = 'False';
            }    
            """)
            verbatim("""
            IsPalindrome {
              s.OneSymbol = 'True';
              /* empty */ = 'True';
              s.Equal e.Middle s.Equal = <IsPalindrome e.Middle>;
              e.Other = 'False';
            }    
            """)
        }

        frame("Пример: сложение двоичных чисел произвольной длины") {
            verbatim("""
            BinAdd {
              e.Num1 '0' '+' e.Num2 '0' = <BinAdd e.Num1 '+' e.Num2> '0';
              e.Num1 '0' '+' e.Num2 '1' = <BinAdd e.Num1 '+' e.Num2> '1';
              e.Num1 '1' '+' e.Num2 '0' = <BinAdd e.Num1 '+' e.Num2> '1';
              e.Num1 '1' '+' e.Num2 '1'
                = <BinAdd <BinAdd e.Num1 '+' '1'> '+' e.Num2> '0';
              /* empty */ '+' e.Num2 = e.Num2;
              e.Num1 '+' /* empty */ = e.Num1;
            }    
            """)
        }

        frame("Структурые скобки") {
            verbatim("('abc') 'def' (('ghi') 'j' ('klm') ()) 'nop' ((('rst')))")
            +"""В выражении на Рефале скобки должны обязательно образовывать правильную 
             скобочную структуру как в левой, так и в правой части предложений. При этом 
             в правой части предложений круглые и угловые скобки не могут накладываться 
             (overlap) друг на друга."""
            itemize {
                -"""E-переменные могут принимать произвольную последовательность термов, 
                 т.е. значением e-переменной может быть только выражение с правильной скобочной 
                 структурой."""
                -"""Значением t-переменных (записываются как t.varname) может быть любой одиночный
                терм — как символ (symbol), так и выражение в скобках."""
            }
        }

        frame("Пример использования структурых скобок") {
            verbatim("""
            IsEqual {
              (e.X) (e.X) = 'True';
              (e.X) (e.Y) = 'False';
            }    
            """)
            verbatim("""
            BinAdd {
              (e.Num1 '0') e.Num2 '0' = <BinAdd (e.Num1) e.Num2> '0';
              (e.Num1 '0') e.Num2 '1' = <BinAdd (e.Num1) e.Num2> '1';
              (e.Num1 '1') e.Num2 '0' = <BinAdd (e.Num1) e.Num2> '1';
              (e.Num1 '1') e.Num2 '1' = <BinAdd (<BinAdd (e.Num1) '1'>) e.Num2> '0';
              (/* empty */) e.Num2 = e.Num2;
              (e.Num1) /* empty */ = e.Num1;
            }    
            """)
        }

        frame("Абстрактная РЕФАЛ-машина") {
            +"""Говорят, что программу на Рефале выполняет абстрактная рефал-машина, — воображаемая вычислительная 
             машина, понимающая синтаксис программ на Рефале. У этой машины есть две области памяти: ${"поле программ".bold()} 
             (program field), хранящее все определения функций программы, и ${"поле зрения".bold()} (view field), хранящее текущее 
             состояние вычислений. Состояние вычислений описывается в виде активного выражения — выражения языка РЕФАЛ, 
             которое содержит скобки активации, но при этом не может содержать переменных."""
        }

        frame("Шаги выполнения РЕФАЛ-машины I") {
            enumerate {
                -"""Рефал-машина находит в поле зрения самую левую пару скобок активации, такой что внутри этого вызова 
                    не находится других угловых скобок. Этот участок поля зрения называется первичным активным 
                    подвыражением (primary active sub-expression)."""
                -"""Рефал-машина смотрит, что находится справа от левой скобки активации: там должно располагаться имя 
                    функции. Если его там нет (язык позволяет написать такую программу), то рефал-машина останавливается
                    с ошибкой «отождествление невозможно» (recognition impossible)."""
                -"""Рефал-машина находит имя функции в поле программ. Функция может быть как написанной на Рефале, так 
                    и встроенной. Если функция встроенная, рефал-машина передаёт управление на процедуру в машинном 
                    коде, реализующую логику этой функции. Если эта функция написана на Рефале, машина выбирает первое 
                    предложение функции."""
            }
        }

        frame("Шаги выполнения РЕФАЛ-машины II") {
            enumerate {
                +"\\setcounter{enumi}{3}" // FIXME
                -"""Если можно подобрать такие значения переменных в левой части текущего предложения, что та обратится 
                    в аргумент функции, то выполняется пункт 5. В противном случае выбирается следующее предложение и 
                    повторяется пункт 4. Если предложений больше нет, то рефал-машина останавливается с ошибкой 
                    «отождествление невозможно»."""
                -"""Найденные значения переменных подставляются в правую часть текущего предложения. Полученное 
                    выражение Рефал-машина вставляет в поле зрения на место первичного активного подвыражения."""
                -"""Если в поле зрения остались скобки активации, то рефал-машина выполняет следующий шаг — 
                    возвращается к пункту 1. В противном случае рефал-машина корректно завершается."""
            }
        }

        frame("Пример с рекурсией") {
            +"""Рассмотрим процесс вычисления функции Fab, 
                заменяющей все литеры 'a' на литеры 'b'"""
            verbatim("""
            ${'$'}ENTRY Go {
              = <Prout <Fab 'abracadabra'>>;
            }
            
            Fab {
              'a' e.Rest = 'b' <Fab e.Rest>;
              s.Other e.Rest = s.Other <Fab e.Rest>;
              /* empty */ = /* empty */;
            }    
            """)
        }

        frame("Типы выражений в РЕФАЛ") {
            itemize {
                -"""${"Объектным выражением".italic()} (object expression) называется выражение языка Рефал, которое может содержать 
                    только символы и круглые скобки. Аргументом функции может быть только объектное выражение."""
                -"""${"Активным выражением".italic()} (active expression) или определённым выражением (ground expression) 
                    называется выражение, которое содержит символы, круглые и угловые скобки. Содержимым поля зрения 
                    может быть только активное выражение."""
                -"""${"Образцовым выражением".italic()} (pattern expression) или образцом (pattern) называется выражение, 
                    составленное из символов, структурных скобок и переменных. Левая часть предложения является 
                    образцовым выражением."""
                -"""${"Результатным выражением".italic()} (result expression) или результатом (result) называется выражение, 
                    содержащее символы, круглые и угловые скобки и переменные. Правые части предложений являются 
                    результатными выражениями."""
            }
        }

//        frame("Диаграмма для типов выражений") {
//            verbatim("""
//         Объектное выражение:        переменные        Образцовое выражение:
//               символы           -> -> -> -> -> -> -> -> ->       символы, круглые
//           и круглые скобки                             скобки, переменные
//                  ↓                                             ↓
//                  ↓ скобки вызова                               ↓ скобки вызова
//                  ↓                                             ↓
//         Активное выражение:         переменные        Результатное выражение:
//          символы, круглые       -> -> -> -> -> -> -> -> ->   символы, круглые и угловые
//          и угловые скобки                               скобки, переменные
//            """)
//        }

        frame("Алгоритм сопоставления с образцом") {
            enumerate {
                -"Подстановка переменных в левую часть должна превращать образец в аргумент функции."
                -"""Значения, подставляемые вместо переменных, должны соответствовать типам этих переменных. 
                    S-, t- и e-переменные могут заменяться только на, соответственно, символы, термы и 
                    произвольные выражения."""
                -"""Если в образце несколько раз встречается переменная с одним и тем же именем, то все её вхождения 
                    должны заменяться на одно и то же значение."""
                -"""Если существует несколько подстановок переменных, соответствующих требованиям 1-3, то выбирается из 
                    них та, у которой длина самого левого вхождения e-переменной является кратчайшей. Если это не 
                    разрешает неоднозначности, то рассматривается следующая e-переменная и т.д."""
            }
        }

        frame("Пример сопоставления с образцом") {
            +"""Рассмотрим сопоставление объектного выражения ${verb("('abra') ('cadabra')")} с 
                образцом ${verb("(e.L1 s.D e.E1) (e.L2 s.D e.R2)")}."""
            verbatim("""
            e.L1 -> [],    s.D -> 'a', e.R1 -> 'bra', e.L2 -> 'c',      e.R2 -> 'dabra'
            e.L1 -> [],    s.D -> 'a', e.R1 -> 'bra', e.L2 -> 'cad',    e.R2 -> 'bra'
            e.L1 -> [],    s.D -> 'a', e.R1 -> 'bra', e.L2 -> 'cadabr', e.R2 -> []
            e.L1 -> 'a',   s.D -> 'b', e.R1 -> 'ra',  e.L2 -> 'cada',   e.R2 -> 'ra'
            e.L1 -> 'ab',  s.D -> 'r', e.R1 -> 'a',   e.L2 -> 'cadab',  e.R2 -> 'a'
            e.L1 -> 'abr', s.D -> 'a', e.R1 -> [],    e.L2 -> 'c',      e.R2 -> 'dabra'
            e.L1 -> 'abr', s.D -> 'a', e.R1 -> [],    e.L2 -> 'cad',    e.R2 -> 'bra'
            e.L1 -> 'abr', s.D -> 'a', e.R1 -> [],    e.L2 -> 'cadabr', e.R2 -> []               
            """)
        }

        frame("Пример сопоставления с образцом: продолжение") {
            +"""Согласно четвёртому пункту будут выбраны те подстановки, у которых самое левое вхождение e-переменной 
                будет кратчайшим. Самая левая e-переменная здесь это e.L1, кратчайшему её вхождению (пустому выражению) 
                соответствуют первые три подстановки:"""
            verbatim("""
            e.L1 -> [], s.D -> 'a', e.R1 -> 'bra', e.L2 -> 'c',      e.R2 -> 'dabra'
            e.L1 -> [], s.D -> 'a', e.R1 -> 'bra', e.L2 -> 'cad',    e.R2 -> 'bra'
            e.L1 -> [], s.D -> 'a', e.R1 -> 'bra', e.L2 -> 'cadabr', e.R2 -> []    
            """)
            +"""Опять неоднозначность. Смотрим на следующую e-переменную. e.R1 во всех трёх случаях имеет одинаковую 
                длину. Смотрим на следующую — e.L2. Кратчайшей подстановке переменной e.L2 среди этих трёх отвечает 
                первая, где e.L2 -> 'c'. Таким образом, будет выбрана подстановка"""
            verbatim("e.L1 -> [], s.D -> 'a', e.R1 -> 'bra', e.L2 -> 'c', e.R2 -> 'dabra'")
        }
    }

}

doc.write("../../../../../tex/lecture02.tex")